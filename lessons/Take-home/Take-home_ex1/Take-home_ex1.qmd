---
title: "Take Home Exercise 1"
author: "Hao Xian"
date: "30 January 2023"
date-modified: "12 February 2023"
execute: 
  echo: true
  eval: true
  warning: true
  message: false

editor: visual
---

# Overview

## Setting the Scene

::: callout-important
This context is taken from the [IS415 Take Home Exercise 1](https://is415-ay2022-23t2.netlify.app/th_ex1.html#setting-the-scene)

All rights belong to Dr Kam Tin Seong.
:::

Water is an important resource to mankind. Clean and accessible water is critical to human health. It provides a healthy environment, a sustainable economy, reduces poverty and ensures peace and security. Yet over 40% of the global population does not have access to sufficient clean water. By 2025, 1.8 billion people will be living in countries or regions with absolute water scarcity, according to UN-Water. The lack of water poses a major threat to several sectors, including food security. Agriculture uses about 70% of the world's accessible freshwater.

Developing countries are most affected by water shortages and poor water quality. Up to 80% of illnesses in the developing world are linked to inadequate water and sanitation. Despite technological advancement, providing clean water to the rural community is still a major development issues in many countries globally, especially countries in the Africa continent.

To address the issue of providing clean and sustainable water supply to the rural community, a global [Water Point Data Exchange (WPdx)](https://www.waterpointdata.org/about/) project has been initiated. The main aim of this initiative is to collect water point related data from rural areas at the water point or small water scheme level and share the data via WPdx Data Repository, a cloud-based data library. What is so special of this project is that data are collected based on [WPDx Data Standard](https://www.waterpointdata.org/wp-content/uploads/2021/04/WPDx_Data_Standard.pdf).

## Objectives

::: callout-important
This Objectives are taken from the IS415 Take Home Exercise 1

All rights belong to Dr Kam Tin Seong.
:::

### Exploratory Spatial Data Analysis

-   Derive kernel density maps of functional and non-functional water points. Using appropriate tmap functions,

-   Display the kernel density maps on openstreetmap of Osub State, Nigeria.

-   Describe the spatial patterns revealed by the kernel density maps. Highlight the advantage of kernel density map over point map.

### Second-Order Spatial Point Patterns Analysis

With reference to the spatial point patterns observed in ESDA:

-   Formulate the null hypothesis and alternative hypothesis and select the confidence level.

-   Perform the test by using appropriate Second order spatial point patterns analysis technique.

-   With reference to the analysis results, draw statistical conclusions.

### Spatial Correlation Analysis

In this section, you are required to confirm statistically if the spatial distribution of functional and non-functional water points are independent from each other.

-   Formulate the null hypothesis and alternative hypothesis and select the confidence level.

-   Perform the test by using appropriate Second order spatial point patterns analysis technique.

-   With reference to the analysis results, draw statistical conclusions.

# Setup

## Packages

-   [**sf**](https://cran.r-project.org/web/packages/sf/index.html): used for importing, managing, and processing geospatial data

-   [**tidyverse**](https://www.tidyverse.org/): for performing data science tasks such as importing, wrangling and visualising data.

-   [**tmap**](https://cran.r-project.org/web/packages/tmap/index.html): used for creating thematic maps, such as choropleth and bubble maps

-   [**spatstat**](https://spatstat.org/): used for point pattern analysis

-   [**raster**](https://cran.r-project.org/web/packages/raster/): reads, writes, manipulates, analyses and models gridded spatial data (i.e.Â raster-based geographical data)

-   [**maptools**](https://cran.r-project.org/web/packages/maptools/index.html): a set of tools for manipulating geographic data

-   [**funModeling**](https://rdrr.io/cran/funModeling/)**:** contains a set of functions related to exploratory data analysis, data preparation, and model performance

## Installing and Loading the Packages

The code chunk below will be used to install and load these packages in RStudio.

```{r}
pacman::p_load(maptools, sf, raster, spatstat, tmap, tidyverse, funModeling)
```

This prepares all the tools necessary for us to start or spatial analysis.

## Dataset used

2 datasets are used for this excercise

1.  The First Dataset used would be the Level 2 Administrative Boundary which can be found either from [Geoboundaries](https://www.geoboundaries.org/index.html#getdata) or [Humanitarian Data Exchange](https://data.humdata.org/group/nga)

2.  [Waterpoint Data Repositories](https://data.waterpointdata.org/dataset/Water-Point-Data-Exchange-Plus-WPdx-/eqje-vguj/data) is the dataset for the waterpoint

# Handling the Geospatial Data

## Importing Geospatial Dataframe

::: callout-note
Need to double check the CRS as it is depending on the system used by the country.

Since the country we are focusing on is Nigeria. The EPSG code is [26392](https://epsg.io/26392)., and it encompasses the entire area of Nigeria.
:::

We will be using the st_read() function from the sf package to read the data set. [More information on st_read() can be found here.](https://r-spatial.github.io/sf/reference/st_read.html).

However, as the polygon data is not in the correct format, there will be a need to convert the geometric data to the correct form. st_transform from the sf package is used to so. [More information on st_transform() can be found here](https://r-spatial.github.io/sf/reference/st_transform.html)

### geoBoundaries data set

This dataset loads the boundaries of Nigeria from geoBoundaries

```{r}
geoNGA <- st_read("data/geospatial/",
                  layer = "geoBoundaries-NGA-ADM2") %>%
  st_transform(crs = 26392)
```

geoNGA contains the following data:

| Columns Name | Description                                    |
|--------------|------------------------------------------------|
| shapeName    | Name of the Level 2 Boundaries                 |
| pcode        | Unique Code                                    |
| level        | ADM2 (Indicating this is a Level 2 Boundaries) |
| shapeID      | Unique Code of the Shape                       |
| shapeGroup   | NGA (Indicating Nigeria)                       |
| shapeType    | ADM2 (Indicating this is a Level 2 Boundaries) |
| geometry     | Polygon Data                                   |

### NGA Data set (Humanitarian Data Exchange) {#nga-data-set-humanitarian-data-exchange}

::: callout-note
The NGA Dataset is essentially the same as geoBoundaries dataset with the exception that the dataset in geoBoundaries is more condense.
:::

```{r}
NGA <- st_read("data/geospatial/",
               layer = "nga_admbnda_adm2_osgof_20190417") %>%
  st_transform(crs = 26392)
```

NGA contains the following data:

| Column Name | Description                            |
|-------------|----------------------------------------|
| Shape_Leng  | Length of the Shape                    |
| Shape_Area  | Area of the Shape                      |
| ADM2_EN     | English Name of ADM2                   |
| ADM2_PCODE  | Unique ID of the ADM2                  |
| ADM2_REF    | A Reference to ADM2_EN                 |
| ADM2ALT1EN  | Alternative English Name               |
| ADM2ALT2EN  | Alternative English Name               |
| ADM1_EN     | ADM1 English Name                      |
| ADM1_PCODE  | Unique ID of ADM1                      |
| ADM0_EN     | ADM0 English Name                      |
| ADM0_PCODE  | Unique ID of ADM0                      |
| date        | Date of the boundaries                 |
| validOn     | Valid Date of the Boundaries           |
| validTo     | End of Valid Date of the Boundaries    |
| SD_EN       | Senatorial District                    |
| SD_PCODE    | Unique Code of the Senatorial District |
| geometry    | Polygon Data                           |

::: callout-important
As NGA seems to offer a more richer data set the rest of the analysis will be done on the NGA Data set
:::

## Importing Aspatial Data

### Loading the dataset from CSV

The next dataset that we will be loading would be the waterpoint dataset. As the dataset is found in the CSV another function read_csv(), which will import the csv as a tibble dataset. [Read more about read_csv() from readr here.](https://readr.tidyverse.org/reference/read_delim.html)

::: callout-note
As the CSV contain almost 70 variables and more than 10000 observations it would be better to filter the dataset to the country of interest, in this case, Nigeria. [Read more about filter() from dplyr here.](https://dplyr.tidyverse.org/reference/filter.html)
:::

```{r}
wp_nga <- read_csv("data/aspatial/WPdx.csv") %>%
  filter(`#clean_country_name` == "Nigeria")
```

### Converting the water point data into sf point feature.

Despite loading the aspatial dataframe into a tibble data frame, we would need to convert the dataframe into an sf data frame for us to perform Geospatial Analysis.

The column "New Georeferenced Column" contain the spatial data is a well-known text representation of geometry, as the such the fuction st_as_sfc() can be used to convert that into a sfc object. [Read more about st_as_sfc() from sf here.](https://www.rdocumentation.org/packages/sf/versions/1.0-9/topics/st_as_sfc) We will append the sfc object into a new Column called "Geometry".

```{r}
wp_nga$Geometry = st_as_sfc(wp_nga$`New Georeferenced Column`)
wp_nga
```

Now than we have a tibble data frame we would need to convert the data frame into a sf object using st_sf(). [Read more about st_sf() here.](https://r-spatial.github.io/sf/reference/sf.html)

::: callout-important
It is important to note that the sfc object in the Geometry column does not contain the correct referencing system. There is a need to transform the projection into a WGS 84. The EPSG code is [4326](https://epsg.io/4326).
:::

```{r}
wp_sf <- st_sf(wp_nga, crs=4326)
wp_sf
```

Much like the Handling of the Geospatial data above, there is a need to conver the WGS84 projection to the projection coordinate system of Nigeria as well.

```{r}
wp_sf <- wp_sf %>%
  st_transform(crs = 26392)
```

# Geospatial Data Cleaning

At this step, we now know that we have already loaded all the dataset and that the next step of it would be cleaning the data.

## Excluding Redundent Fields

Taking a look at the columns ([NGA Data set (Humanitarian Data Exchange)](#nga-data-set-humanitarian-data-exchange))of the NGA sf dataframe, we could identify most of the redundent fields. The only field that really matters would be the columns

| Columns to Keep | Reasons                                                                        |
|------------------|------------------------------------------------------|
| ADM2_EN         | This is the English Name of the ADM2. This is where the Local Government Area. |
| ADM2_PCODE      | This is the unique identifier of ADM2                                          |
| ADM1_EN         | This is the English Name of the ADM1. This is where the States of Nigeria is.  |
| ADM1_PCODE      | This is the unique identifier of ADM1                                          |

```{r}
NGA <- NGA %>%
  select(c(3:4, 8:9))
```

## Checking for Duplicate Name

We need to ensure that there is no duplicate name in the data. In this case, we only really care about checking for duplicate names in Local Government Area or ADM2. One method we can used to check for duplicated name would the used of the duplicated() function. [Find out about the duplicated() from base R here.](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/duplicated)

```{r}
NGA$ADM2_EN[duplicated(NGA$ADM2_EN)==TRUE]
```

Now that we know that there are similarities in the name we would need to examine the duplicate field more closely. One method we can used to check if the duplicated data are the same would be to take a look at their unique pcode.

```{r}
NGA$ADM2_PCODE[duplicated(NGA$ADM2_PCODE)==TRUE]
```

Now that we have establised that each of ADM2_PCODE is different, we can determined that the ADM2 names are the same but are referencing different area. In this case, there will be a need to correct the names of the ADM2_EN so that there will be no duplicate data.

::: callout-tip
A Google Search can be performed as well to double check they are indeed different area.
:::

```{r}
NGA$ADM2_EN[94] <- "Bassa, Kogi"
NGA$ADM2_EN[95] <- "Bassa, Plateau"
NGA$ADM2_EN[304] <- "Ifelodun, Kwara"
NGA$ADM2_EN[305] <- "Ifelodun, Osun"
NGA$ADM2_EN[355] <- "Irepodun, Kwara"
NGA$ADM2_EN[356] <- "Irepodun, Osun"
NGA$ADM2_EN[519] <- "Nasarawa, Kano"
NGA$ADM2_EN[520] <- "Nasarawa, Nasarawa"
NGA$ADM2_EN[546] <- "Obi, Benue"
NGA$ADM2_EN[547] <- "Obi, Nasarawa"
NGA$ADM2_EN[693] <- "Surulere, Lagos"
NGA$ADM2_EN[694] <- "Surulere, Oyo"
```

Now, we would need to confirm that the duplicated name issues has been addressed already.

```{r}
NGA$ADM2_EN[duplicated(NGA$ADM2_EN)==TRUE]
```

# Data Wrangling for Water Point Data

Before we go about extracting the relevant details from the Water Point Data, we could perform some Exploratory Data Analysis to gain some initial understanding of the data.

::: callout-note
Note that we need to use the sf Dataframe for most of the analysis.
:::

We can view the distribution of the water point through the use of freq() function of funModeling package. [Find out about freq() from funModeling here.](https://rdrr.io/cran/funModeling/man/freq.html)

```{r}
freq(data = wp_sf,
     input = '#status_clean')
```

Let perform some analysis on the status of the water points. There seems to be 3 broad categories of the water point based on their status:

-   functional

-   non-functional

-   unknown.

However, some data wrangling task would need to be performed in order to make it easier to handle in subsequent steps

-   We would need to rename the "#status_clean" to "status_clean". This is done through the use of rename() function from dplyr package. [Find out more about rename() function from dplyr here.](https://dplyr.tidyverse.org/reference/rename.html)

-   After we have rename the column, we would need to select it into a new data frame. This is done through the use of select() function from dplyr package. [Find out more about select() function from dplyr here.](https://dplyr.tidyverse.org/reference/select.html)

-   Lastly, we would need replace all the NA value with "unknown". this can be done through mutate() function and replace_na() function. [Find out more about mutate() function here.](https://dplyr.tidyverse.org/reference/mutate.html) [Find out more about replace_na() function here.](https://tidyr.tidyverse.org/reference/replace_na.html)

```{r}
wp_sf_nga <- wp_sf %>% 
  rename(status_clean = '#status_clean') %>%
  select(status_clean) %>%
  mutate(status_clean = replace_na(
    status_clean, "unknown"))
```

## Extracting the Water Point Data

With some basic understanding of the water point, we can now categories the water point data. From the graph above we can categories it into the following method.

| Waterpoint Category | Status                           |
|---------------------|----------------------------------|
| Functional          | Functional                       |
| Functional          | Functional but not in use        |
| Functional          | Functional but needs repair      |
| Non Functional      | Abandoned/Decommissioned         |
| Non Functional      | Abandoned                        |
| Non Functional      | Non-Functional due to dry season |
| Non Functional      | Non-Functional                   |
| Non Functional      | Non functional due to dry season |
| Unknown             | Unknown                          |

: This is to extract functional water point

```{r}
wp_functional <- wp_sf_nga %>%
  filter(status_clean %in%
           c("Functional",
             "Functional but not in use",
             "Functional but needs repair"))
```

```{r}
wp_functional
```

This is to extract nonfunctional water point.

```{r}
wp_nonfunctional <- wp_sf_nga %>%
  filter(status_clean %in%
           c("Abandoned/Decommissioned",
             "Abandoned",
             "Non-Functional due to dry season",
             "Non-Functional",
             "Non functional due to dry season"))
```

```{r}
wp_nonfunctional
```

This is to extract unknown water point

```{r}
wp_unknown <- wp_sf_nga %>%
  filter(status_clean == "unknown")
```

```{r}
wp_unknown
```

## EDA on waterpoints

Now that we have extracted the water point data, we can have a better look at water points from each category.

This is for Functional Water point

```{r}
freq(data = wp_functional,
     input = 'status_clean')
```

This is for Non Functional Water Point

```{r}
freq(data = wp_nonfunctional,
     input = 'status_clean')
```

This is Unknown Water Point

```{r}
freq(data = wp_unknown,
     input = 'status_clean')
```

## Performing Point In Polygon Count.

While knowing the number of total functional and nonfunctional and unknown water point is important, it would be better if we are able to see the status of each water point in each of the LGA.

To do that we would need to perform a series of steps.

-   We would need to make use of the st_intersects() function of sf package to identify the functional water points in each LGA. [Find out more about st_intersects() function of sf package here](https://r-spatial.github.io/sf/reference/geos_binary_pred.html)

-   We would need to make use of lengths() function from base r to calculate the number of functional water points that fall inside each LGA. [Find out more about lengths() function of base r here](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/lengths).

All of this is added to a new sf data frame "NGA_wp" to be used in subsequent steps.

```{r}
NGA_wp <- NGA %>% 
  mutate(`total_wp` = lengths(
    st_intersects(NGA, wp_sf_nga))) %>%
  mutate(`wp_functional` = lengths(
    st_intersects(NGA, wp_functional))) %>%
  mutate(`wp_nonfunctional` = lengths(
    st_intersects(NGA, wp_nonfunctional))) %>%
  mutate(`wp_unknown` = lengths(
    st_intersects(NGA, wp_unknown)))
```

## Visualising Attributes

Now that we have the point in polygon count we can reveal the distribution of the waterpoint.

We can make use of the ggplot2 packages to help plot. ggplot2 is part of tidyverse, and more information can be found [here](https://ggplot2.tidyverse.org/).

Distribution of Total Water point

```{r}
ggplot(data = NGA_wp,
       aes(x = wp_functional)) + 
  geom_histogram(bins=20,
                 color="black",
                 fill="light blue") +
  geom_vline(aes(xintercept=mean(
    total_wp, na.rm=T)),
             color="red", 
             linetype="dashed", 
             size=0.8) +
  ggtitle("Distribution of total water points by LGA") +
  xlab("No. of water points") +
  ylab("No. of\nLGAs") +
  theme(axis.title.y=element_text(angle = 0))
```

Distribution of Functional Water point

```{r}
ggplot(data = NGA_wp,
       aes(x = wp_nonfunctional)) + 
  geom_histogram(bins=20,
                 color="black",
                 fill="light blue") +
  geom_vline(aes(xintercept=mean(
    total_wp, na.rm=T)),
             color="red", 
             linetype="dashed", 
             size=0.8) +
  ggtitle("Distribution of total water points by LGA") +
  xlab("No. of water points") +
  ylab("No. of\nLGAs") +
  theme(axis.title.y=element_text(angle = 0))
```

Distribution of Non Functional Water point

```{r}
ggplot(data = NGA_wp,
       aes(x = total_wp)) + 
  geom_histogram(bins=20,
                 color="black",
                 fill="light blue") +
  geom_vline(aes(xintercept=mean(
    total_wp, na.rm=T)),
             color="red", 
             linetype="dashed", 
             size=0.8) +
  ggtitle("Distribution of total water points by LGA") +
  xlab("No. of water points") +
  ylab("No. of\nLGAs") +
  theme(axis.title.y=element_text(angle = 0))
```

Distribution of Unknown Water point

```{r}
ggplot(data = NGA_wp,
       aes(x = wp_unknown)) + 
  geom_histogram(bins=20,
                 color="black",
                 fill="light blue") +
  geom_vline(aes(xintercept=mean(
    total_wp, na.rm=T)),
             color="red", 
             linetype="dashed", 
             size=0.8) +
  ggtitle("Distribution of total water points by LGA") +
  xlab("No. of water points") +
  ylab("No. of\nLGAs") +
  theme(axis.title.y=element_text(angle = 0))
```

# Saving the Data into RDS format

Now that we have done all the above work in order to get sf object structure for us to perform geospatial analytics, it would be a shame if all the hardwork is gone. As such, it is important that we save the data into rds format.

We can make use of the write_rds() function from readr package to export the sf dataframe into a rds format. [Find out more about write_rds() function from readr package here.](https://readr.tidyverse.org/reference/read_rds.html)

::: callout-note
RDS format is a R native data format, which allows for R object to be save for later used.
:::

```{r}
write_rds(NGA_wp, "data/rds/NGA_wp.rds")
```

# Mapping the Functional and Non Functional Points

Now that we have save the Data in RDS, why not we plot the relevant data into an interactive map for you to see.

We are making use of tmap package to help us in the plotting of the map. [Find out more about tmap package here.](https://cran.r-project.org/web/packages/tmap/vignettes/tmap-getstarted.html)

```{r}
tmap_mode("view")
tm_shape(NGA) +
  tm_polygons() +
tm_shape(wp_functional)+ 
  tm_dots(col = "status_clean",
             size = 0.01,
             border.col = "black",
             border.lwd = 0.5,
          palette = "blue") + 
  tm_shape(wp_nonfunctional)+ 
  tm_dots(col = "status_clean",
             size = 0.01,
             border.col = "black",
             border.lwd = 0.5,
          palette = "red") +
  tm_view(set.zoom.limits = c(6, 10))
```

::: callout-note
After setting tmap_mode to view. We need to set the tmap_mode back to plot
:::

```{r}
tmap_mode("plot")
```

In the event that the above map, takes too long to load, you can view the entire map of Nigeria here.

::: callout-note
This is generated with tmap as well however, the mode is set to plot, hence a static map is generated.
:::

```{r}
tm_shape(NGA) +
  tm_borders(col = "grey40", lwd = 1, lty = "solid")+
tm_shape(wp_functional)+
  tm_dots(legend.show = TRUE, col = "blue") +
  tm_shape(wp_nonfunctional) +
  tm_dots(legend.show = TRUE, col = "red") 
```

# Geospatial Data Wrangling

## Converting sf data to sp's Spatial Class

As sp's Spatial Class is still commonly used by most of the spatial analysis packages as such we would need to convert the data frame into Spatial Class.

This can be done with the function as_Spatial() function of the sf package. [Find out more about as_Spatial() from sf package here.](https://www.rdocumentation.org/packages/sf/versions/0.3-4/topics/as_Spatial)

```{r}
wp_functional_spatial <- as_Spatial(wp_functional)
wp_nonfunctional_spatial <- as_Spatial(wp_nonfunctional)
NGA_spatial <- as_Spatial(NGA)
```

### Viewing each of the sp Spatial Class

Here we will view the Spatial Class of the converted data frame.

[**Functional**]{.underline}

```{r}
wp_functional_spatial 
```

[**Non Functional**]{.underline}

```{r}
wp_nonfunctional_spatial
```

[**NGA**]{.underline}

```{r}
NGA_spatial
```

## Converting the Spatial Class into generic sp format

The main package that we are using to analyse out data would be [spatstat](https://cran.r-project.org/web/packages/spatstat/index.html). However, this requires our analytical data to be in the ppp object form.

However, there is no direct way for us to convert a Spatial class into a ppp object. It would need to be converted into a Spatial object first before we can convert it into a ppp object.

We can make use of the as() function from basic R to convert it into a Spatial Object. [Find out more about as() function here.](https://www.rdocumentation.org/packages/methods/versions/3.6.2/topics/as)

::: callout-note
Note that we are converting the point into Spatial Points, while we are converting the boundaries into "Spatial Polygons"
:::

```{r}
wp_functional_sp <- as(wp_functional_spatial, "SpatialPoints")
wp_nonfunctional_sp <- as(wp_nonfunctional_spatial, "SpatialPoints")
NGA_sp <- as(NGA_spatial, "SpatialPolygons")
```

### Viewing each of the Spatial Points

[Functional]{.underline}

```{r}
wp_functional_sp 
```

[Non Functional]{.underline}

```{r}
wp_nonfunctional_sp
```

[NGA]{.underline}

```{r}
NGA_sp
```

## Converting into spatstas ppp format

We can now convert the Spatial Object into a ppp format

```{r}
wp_functional_ppp <- as(wp_functional_sp , "ppp")
wp_nonfunctional_ppp <- as(wp_nonfunctional_sp , "ppp")
```

### Viewing each ppp format

[Functional]{.underline}

```{r}
wp_functional_ppp
```

[Non Functional]{.underline}

```{r}
wp_nonfunctional_ppp
```

### Checking for Duplicate Points

::: callout-note
It is important to check for Duplicate Points, and there are many methods of handling duplicate points such as rjitter().
:::

We would now need to perform a check to make sure that there is no duplicated points. which we can check using the

```{r}
any(duplicated(wp_functional_ppp))
```

```{r}
any(duplicated(wp_nonfunctional_ppp))
```

Since the result is False, it seems that there is no special need to perform other actions to fix the duplicated data.

## Creating Owin Object

::: callout-note
An owin object is used to define the polygonal region of the Region of interest.
:::

We will now wish to confine the geographical area boundary to that of Nigeria, as such we can convert the Spatial Polygon object into owin to help us represent this polygonal region.

```{r}
NGA_owin <- as(NGA_sp, "owin")
```

### Plotting the Owin

```{r}
plot(NGA_owin)
```

### Combining Non Functional Water Point and Functional Water Point with Owin

Now then we can extract the water point events and combine it with the owin data.

```{r}
wp_functional_NGA_ppp = wp_functional_ppp[NGA_owin]
```

```{r}
wp_nonfunctional_NGA_ppp = wp_nonfunctional_ppp[NGA_owin]
```

### Plotting the Owin Object with Water Points

Now we will plot the owin object to see if we it was successful.

[Functional]{.underline}

```{r}
plot(wp_functional_NGA_ppp)
```

[Non Functional]{.underline}

```{r}
plot(wp_nonfunctional_NGA_ppp)
```

# Kernel Density Estimation

As you can see from the owin map data above, it appears it is extremely difficult to gain any insights from the map above. Based on how dark the region, we can assume that there is where most of the waterpoint are, but there is a much better map we can use and that would be Kernal Density Map.

As such we would need perform Kernel Density Estimation to measure the intensity of the point process.

## Rescaling the KDE values

One issue with the ppp data is that the unit of measurement is in meters, which will cause out density values to be very small.

As such there is a needed to convert the unit measurement into kilometer in order for the density to make better sense.

```{r}
wp_functional_NGA_ppp.km <- rescale(wp_functional_NGA_ppp, 1000, "km")
wp_nonfunctional_NGA_ppp.km <- rescale(wp_nonfunctional_NGA_ppp, 1000, "km")
```

## Plotting the Kernal Density Map

Now that we have rescaled the data set we can perform Kernel Density Estimation on the datasets.

We can make use of the density() function from the spatstat package to help us generate the Kernal Density map. [Find out more about density() from spatstat here.,](https://www.rdocumentation.org/packages/spatstat/versions/1.64-1/topics/density.ppp) We will making use of the automatic bandwidth methods here.

::: callout-note
One thing to note is that there are a 3 different spatstat function for us to use to determine the bandwidth, called bw.CvL, bw.scott and bw.ppl. And also kernel needs to be determined as well (I will be using the default "Gaussian".

[According to research by Prof](https://r4gdsa.netlify.app/chap04.html), it was suggested that bw.ppl() is more appropriate to use, when patterns consist predominantly of tight cluster. bw.diggle() is used when the we are trying to detect a single tight cluster in the midst of random noise. [However, both are more commonly use.](https://maczokni.github.io/crime_mapping_textbook/studying-spatial-point-patterns.html)

I have chosen to use diggle(), but results might vary if bw.ppl() is used.
:::

[Functional Kernal Density Map]{.underline}

```{r}
wp_functional_NGA.bw <- density(wp_functional_NGA_ppp.km, sigma=bw.diggle, edge=TRUE, kernel="gaussian")
plot(wp_functional_NGA.bw)
```

[Non Functional Kernal Density Map]{.underline}

```{r}
wp_nonfunctional_NGA.bw <- density(wp_nonfunctional_NGA_ppp.km, sigma=bw.diggle, edge=TRUE, kernel="gaussian")
plot(wp_nonfunctional_NGA.bw)
```

## Converting to Grid Object

We would need to convert the KDE into a suitable format for mapping purpose. The format we are converting would be a Grid Object

[Functional]{.underline}

```{r}
gridded_kde_wp_functional_NG_bw <- as.SpatialGridDataFrame.im(wp_functional_NGA.bw)
spplot(gridded_kde_wp_functional_NG_bw)
```

[Non Functional]{.underline}

```{r}
gridded_kde_wp_nonfunctional_NG_bw <- as.SpatialGridDataFrame.im(wp_nonfunctional_NGA.bw)
spplot(gridded_kde_wp_nonfunctional_NG_bw)
```

## Converting to Raster

After we have converted the data into a Grid Object we would need to convert that into a Raster Layer. We can make use of raster() function of raster package to help us convert. [Find out more about raster package here](https://www.rdocumentation.org/packages/raster/versions/2.5-8/topics/raster).

Raster object is accepted by tmap as one of the layer for plotting. as such we will be converting it into a raster object

```{r}
kde_wp_functional_NG_bw_raster <- raster(gridded_kde_wp_functional_NG_bw)
kde_wp_nonfunctional_NG_raster <- raster(gridded_kde_wp_nonfunctional_NG_bw)
```

::: callout-note
However, a raster object does not have any CRS information. We would need to project the CRS information into the raster layer. In this case the EPSG code is 26392.
:::

```{r}
projection(kde_wp_functional_NG_bw_raster) <- CRS("+init=EPSG:26392")
projection(kde_wp_nonfunctional_NG_raster) <- CRS("+init=EPSG:26392")
```

### Viewing Raster Object

[Functional]{.underline}

```{r}
kde_wp_functional_NG_bw_raster
```

[Non Functional]{.underline}

```{r}
kde_wp_nonfunctional_NG_raster
```

# Plotting Kernal Density Map of Whole Nigeria

Now that we have the Kernal Density Map of the whole Nigeria, we can plot it using tmap

[Functional]{.underline}

```{r}
tm_shape(kde_wp_functional_NG_bw_raster) + 
    tm_layout(main.title = "KDE of Functional Water Point (NGE)") +
  tm_raster("v") +
  tm_layout(legend.position = c("right", "bottom"), frame = FALSE)
```

[Non Functional]{.underline}

```{r}
tm_shape(kde_wp_nonfunctional_NG_raster) + 
    tm_layout(main.title = "KDE of Non Functional Water Point (NGE)") +
  tm_raster("v") +
  tm_layout(legend.position = c("right", "bottom"), frame = FALSE)
```

# Plotting Kernal Density Map of Osun Area

::: callout-note
Most of the Steps here can be found above.
:::

## Extracting Osun State from NGA

We can now perform the same steps as above to generate the Kernal Density Map of Osun Area.

```{r}
osun = NGA_spatial[NGA_spatial@data$ADM1_EN == "Osun",]
```

```{r}
plot(osun)
```

```{r}
osun_sp = as(osun, "SpatialPolygons")
```

```{r}
osun_owin = as(osun_sp, "owin")
```

## Merging Water Data point with Osun Owin

```{r}
wp_functional_osun_ppp = wp_functional_ppp[osun_owin]
wp_nonfunctional_osun_ppp = wp_nonfunctional_ppp[osun_owin]
```

### Rescaling Data Points

```{r}
wp_functional_osun_ppp.km = rescale(wp_functional_osun_ppp, 1000, "km")
wp_nonfunctional_osun_ppp.km = rescale(wp_nonfunctional_osun_ppp, 1000, "km")
```

We will plot a map of the functional water point of osun to take a look.

```{r}
plot(wp_functional_osun_ppp.km)
```

## Generating KDE

```{r}
wp_nonfunctional_osun.bw <- density(wp_nonfunctional_osun_ppp.km, sigma=bw.diggle, edge=TRUE, kernel="gaussian")
plot(wp_nonfunctional_osun.bw)
```

```{r}
wp_functional_osun.bw <- density(wp_functional_osun_ppp.km, sigma=bw.diggle, edge=TRUE, kernel="gaussian")
plot(wp_functional_osun.bw)
```

## Converting KDE to Raster

```{r}
gridded_kde_wp_functional_osun_bw <- as.SpatialGridDataFrame.im(wp_functional_osun.bw)
spplot(gridded_kde_wp_functional_osun_bw)
```

```{r}
gridded_kde_wp_nonfunctional_osun_bw <- as.SpatialGridDataFrame.im(wp_nonfunctional_osun.bw)
spplot(gridded_kde_wp_nonfunctional_osun_bw)
```

```{r}
kde_wp_functional_osun_bw_raster <- raster(gridded_kde_wp_functional_osun_bw)
kde_wp_nonfunctional_osun_bw_raster <- raster(gridded_kde_wp_nonfunctional_osun_bw)
```

```{r}
projection(kde_wp_functional_osun_bw_raster) <- CRS("+init=EPSG:26393")
projection(kde_wp_nonfunctional_osun_bw_raster) <- CRS("+init=EPSG:26393")
```

```{r}
kde_wp_functional_osun_bw_raster
```

## Plotting KDE of Osun

```{r}
tm_shape(kde_wp_functional_osun_bw_raster) + 
    tm_layout(main.title = "KDE of Functional Water Point (Osun)") +
  tm_raster("v") +
  tm_layout(legend.position = c("right", "bottom"), frame = FALSE)
```

```{r}
tm_shape(kde_wp_nonfunctional_osun_bw_raster) + 
    tm_layout(main.title = "KDE of Non Functional Water Point (Osun)") +
  tm_raster("v") +
  tm_layout(legend.position = c("right", "bottom"), frame = FALSE)
```

# Analysis of Kernal Density Points

## Testing for Distribution Clarks and Evens

::: callout-note
Clarks and Evants Test is a Test of Aggregation, Further Testing would need to be performed in order for us to determine if the Hypothesis is True. [Find out more about clarksevans.test() here.](https://www.rdocumentation.org/packages/spatstat/versions/1.63-3/topics/clarkevans.test)
:::

The test hypotheses are:

Ho = The distribution of water points in Osun are randomly distributed.

H1= The distribution of water points in Osun are not randomly distributed.

The 95% confident interval will be used.

```{r}
clarkevans.test(wp_functional_osun_ppp,
                correction="none",
                clipregion="sg_owin",
                alternative=c("clustered"),
                nsim=99)
```

::: callout-note
We therefore reject the null Hypothesis that the Functional water point are randomly distributed as the p-value is greater than 0.01.
:::

```{r}
clarkevans.test(wp_nonfunctional_osun_ppp,
                correction="none",
                clipregion="sg_owin",
                alternative=c("clustered"),
                nsim=99)
```

::: callout-note
We therefore reject the null Hypothesis that the non Functional water point are randomly distributed as the p-value is greater than 0.01.
:::

## Analysis of Functional and Non Functional Water point

When looking at the 2 Kernal Density Map, it is easy to assume that there seems to be almost no pattern on the density of the water point, however, one can easily assume that there is no pattern in where all the water points are located.

However upon further inspection, there seems to be 2 trends that can be spotted based in the difference in map density. In other to help out in the spotting of the trend, a map of Osun from Google map was include below for the trend to be more easily view able.

### Areas with High Functional Water Point and Non Functional Water Point are clustered together in the cities in Osun.

![Copyrighted: Taken from Google Maps](images/Capture.PNG)

Taking a look at the map above and comparing it with the KDE Map, areas with high density of functional and non functional water points seems to coincide with where the cities are located. This seems to make the most sense as cities are where most people lives and need the access to water, as such it make sense most of the water point to concentrate itself in the cities.

In this regards, Large cities tend to have a larger concentration of functional and non functional water points as compared to smaller cities. On the other hand, areas of very low human density such as the Both Nature Reserve seem to have almost no Water Points whether they are functional or not.

::: callout-important
*Based on this observations, we can hypothesis that both the Functional Water Point and Non Functional Water Point are clustered together in the state of Osun. Further Validation using Second Spatial Point Pattern Analysis would need to be performed.*
:::

### Functional and Non Functional Water Point are clustered together in cities of Osun

![Functional Water Point KDE](images/view.PNG)

![Non Functional Water Point KDE](images/view2.PNG)

We have already establish in the previous observation that Most of the Water Points in the Cities. When we observed the density of the Functional Water Points and Non Functional Water Points in the state, we come to a hypothesis that the water points are clustered together in the State of Osun. However, if we were to inspect the KDE of both water points more closely focusing on the cities, we have reason to believe that the functional water and non functional water points are clustered together among themselves in the cities as well.

The 2 images above are captures of the cities of Ede. Despite both being in the same city, the water points appeared to be clustered together as well. This can be observed in other points in the Functional Water Point KDE and Non Functional Water Point KDE as well.

::: callout-important
*Based on this observations, we can hypothesis that both the Functional Water Point and Non Functional Water Point are clustered together in the cities of the state of Osun. Further Validation using Second Spatial Point Pattern Analysis would need to be performed.*
:::

## Comparison between Kernel Density Map and Point Map.

### Kernel Density Map are better at spotting trends as compared to Point Map

Kernal Density Map are much better at spotting trends as compared to that of the point map. A Point map will highlight each individual water point out and this can be difficult for us to determine any trend at all.

With reference to the map in [Mapping the Functional and Non Functional Points], there seems to be almost no difference in the density of the water points in the area, or at the very least it is difficult to tell. A Kernel Density Map solve this by smoothing over the points and providing a density number, whereas for Point Map, we can only observed the areas based on the number of points. T

*Kernel Density Map provides a Quantitative Value as compared to the Qualitative observation of Point Map in detecting trends.*

### Kernal Density Map are less computationally intensive to display as compared to Point Map in an interactive map

A Point Map with it thousands of points is more computationally intensive to display are compared to Kernal Density Map. This is because the computer would need to take note of every individual point and plot it out which would be an issue for computers with low computational power.

### Kernel Density Map is able to provide an estimation of the concentration of points.

Kernel Density takes into account the inverse-distance weighted counts of the existing point to estimate the concentration of points in an given area. This means that the estimated cells values are derived based on the weights of the existing points, with the furthest points having the lowest weights. This process in turns smooth the density generated and can help to give a more pronounced gradient.

[Find out more about Inverse Distance Weighted here.](https://pro.arcgis.com/en/pro-app/latest/help/analysis/geostatistical-analyst/how-inverse-distance-weighted-interpolation-works.htm)

# 2nd Order Spatial Point Analysis

Now that we have analysed the spatial point patterns, we would need to confirm our observations statistically - which is where hypothesis comes in.

Our Hypothesis:

-   H0: The distribution of the Functional Water Points are randomly distributed

-   H1: The distribution of the Non Functional Water Points are not randomly distributed

-   Confidence level : 99%

We will be performing the Hypothesis Testing for 3 different cities that I have selected and that would be the Osogbo, Ede and Iwo. We will also be performing it on the State of Osun.

Before that we would need to extract the water points data from the 3 cities as well, following the same steps we did to extract the data of the Osun State.

## Defining the Areas

```{r}
iwo = NGA_spatial[NGA_spatial@data$ADM2_EN == "Iwo",] 
osogbo = NGA_spatial[NGA_spatial@data$ADM2_EN == "Osogbo",]
ede = NGA_spatial[NGA_spatial@data$ADM2_EN %in% c("Ede North","Ede South"),]
```

```{r}
iwo_sp = as(iwo, "SpatialPolygons")
osogbo_sp = as(osogbo, "SpatialPolygons")
ede_sp = as(ede, "SpatialPolygons")
```

```{r}
iwo_owin = as(iwo, "owin")
osogbo_owin = as(osogbo, "owin")
ede_owin = as(ede, "owin")
```

```{r}
wp_functional_iwo_ppp = wp_functional_ppp[iwo_owin]
wp_nonfunctional_iwo_ppp = wp_nonfunctional_ppp[iwo_owin]

wp_functional_osogbo_ppp = wp_functional_ppp[osogbo_owin]
wp_nonfunctional_osogbo_ppp = wp_nonfunctional_ppp[osogbo_owin]

wp_functional_ede_ppp = wp_functional_ppp[ede_owin]
wp_nonfunctional_ede_ppp = wp_nonfunctional_ppp[ede_owin]
```

```{r}
wp_functional_iwo_ppp.km = rescale(wp_functional_iwo_ppp, 1000, "km")
wp_nonfunctional_iwo_ppp.km = rescale(wp_nonfunctional_iwo_ppp, 1000, "km")

wp_functional_osogbo_ppp.km = rescale(wp_functional_osogbo_ppp, 1000, "km")
wp_nonfunctional_osogbo_ppp.km = rescale(wp_nonfunctional_osogbo_ppp, 1000, "km")

wp_functional_ede_ppp.km = rescale(wp_functional_ede_ppp, 1000, "km")
wp_nonfunctional_ede_ppp.km = rescale(wp_nonfunctional_ede_ppp, 1000, "km")

```

## Computing G Function

Now that we have extracted the dataset for the 3 cities and converted it into ppp format we can now perform our 2nd Order Spatial Analysis on them.

For this we have chose to use G Function to test our Hypothesis. [As stated by our Professor,](https://r4gdsa.netlify.app/chap05.html#second-order-spatial-point-patterns-analysis) G Function is a measure of the distribution from an arbitrary event to its nearest event. It estimates the nearest neighbour distance distribution from a point pattern in a window of arbitrary shape. It is recommended that [G Function is a useful statistic summarising one aspect of the \`\`clustering'' of points.](https://www.rdocumentation.org/packages/spatstat.core/versions/2.3-1/topics/Gest) As such we will make use of G Function to test our Hypothesis on whether the points are randomly distributed or not.

For us to perform G Function Analysis we will be making use of Gest() Function from spatstat. F[ind out more about Gest() from spatstat here.](https://www.rdocumentation.org/packages/spatstat.core/versions/2.3-1/topics/Gest) To further confirm our Hypothesis we would need to perform a Monte Carlo Simulation Test with G Function to test our Hypothesis.

### Iwo

#### Computing G_Function Estimation for Functional Water Point

```{r}
G_iwo = Gest(wp_functional_iwo_ppp.km, correction = "border")
plot(G_iwo)
```

#### Testing the Hypothesis of Functional Water Point

**Our Hypothesis:**

-   H0: The distribution of the Functional Water Points in Iwo are randomly distributed

-   H1: The distribution of the Functional Water Points in Iwo are not randomly distributed

-   Confidence level : 99%

-   Significance level : 0.01

-   The null hypothesis will be rejected if p-value is smaller than alpha value of 0.01.

```{r}
G_iwo_fuctional.csr <- envelope(wp_functional_iwo_ppp.km, Gest, nsim=100)
```

```{r}
plot(G_iwo_fuctional.csr)
```

::: callout-important
**Conclusion:** The observed G(r) is far above the G(theo) as well as the envelope - indicating that Functional Water Point in the Iwo area are clustered. Hence, we reject the null hypothesis that Functional Water Point in the Iwo area are randomly distributed at 99% confident interval**.**
:::

#### Computing G_Fuction Estimate for Non Functional Water Point

```{r}
G_iwo_non = Gest(wp_nonfunctional_iwo_ppp.km, correction = "border")
plot(G_iwo_non)
```

#### Testing the Hypothesis of Non Functional Water Point

**Our Hypothesis:**

-   H0: The distribution of the Non Functional Water Points in Iwo are randomly distributed

-   H1: The distribution of the Non Functional Water Points in Iwo are not randomly distributed

-   Confidence level : 99%

-   Significance level : 0.01

-   The null hypothesis will be rejected if p-value is smaller than alpha value of 0.01.

```{r}
G_iwo_nonfuctional.csr <- envelope(wp_nonfunctional_iwo_ppp.km, Gest, nsim=100)
```

```{r}
plot(G_iwo_nonfuctional.csr)
```

::: callout-important
**Conclusion:** The observed G(r) is far above the G(theo) as well as the envelope - indicating that Non Functional Water Point in the Iwo area are clustered. Hence, we reject the null hypothesis that Non Functional Water Point in the Iwo area are randomly distributed at 99% confident interval**.**
:::

### Osogbo

#### Computing G-Fuction Estimate of Functional Water Point

```{r}
G_osogbo = Gest(wp_functional_osogbo_ppp.km, correction = "border")
plot(G_osogbo)
```

#### Testing the Hypothesis of Functional Water Point

**Our Hypothesis:**

-   H0: The distribution of the Functional Water Points in Osogbo are randomly distributed

-   H1: The distribution of the Functional Water Points in Osogbo are not randomly distributed

-   Confidence level : 99%

-   Significance level : 0.01

-   The null hypothesis will be rejected if p-value is smaller than alpha value of 0.01.

```{r}
G_osogbo_fuctional.csr <- envelope(wp_functional_osogbo_ppp.km, Gest, nsim=100)
```

```{r}
plot(G_osogbo_fuctional.csr)
```

::: callout-important
**Conclusion**: The observed G(r) is far above the G(theo) as well as the envelope - indicating that Functional Water Point in the Osogbo area are clustered. Hence, we reject the null hypothesis that Functional Water Point in the Osogbo area are randomly distributed at 99% confident interval**.**
:::

#### Computing G_Function Estimate for Non Functional Water Point

```{r}
G_osogbo_non = Gest(wp_nonfunctional_osogbo_ppp.km, correction = "border")
plot(G_osogbo_non)
```

#### Testing the Hypothesis of Non Functional Water Point

**Our Hypothesis:**

-   H0: The distribution of the Non Functional Water Points in Osogbo are randomly distributed

-   H1: The distribution of the Non Functional Water Points in Osogbo are not randomly distributed

-   Confidence level : 99%

-   Significance level : 0.01

-   The null hypothesis will be rejected if p-value is smaller than alpha value of 0.01.

```{r}
G_osogbo_nonfuctional.csr <- envelope(wp_nonfunctional_osogbo_ppp.km, Gest, nsim=100)
```

```{r}
plot(G_osogbo_nonfuctional.csr)
```

::: callout-important
**Conclusion**: The observed G(r) is far above the G(theo) as well as the envelope - indicating that Non Functional Water Point in the Osobo area are clustered. Hence, we reject the null hypothesis that Non Functional Water Point in the Osobo area are randomly distributed at 99% confident interval**.**
:::

### Ede

#### Computing G_Function Estimate for Functional Water Point

```{r}
G_ede = Gest(wp_functional_ede_ppp.km, correction = "border")
plot(G_ede)
```

#### Testing the Hypothesis of Functional Water Point

**Our Hypothesis:**

-   H0: The distribution of the Functional Water Points in Ede are randomly distributed

-   H1: The distribution of the Functional Water Points in Ede are not randomly distributed

-   Confidence level : 99%

-   Significance level : 0.01

-   The null hypothesis will be rejected if p-value is smaller than alpha value of 0.01.

```{r}
G_ede_fuctional.csr <- envelope(wp_functional_ede_ppp.km, Gest, nsim=100)
```

```{r}
plot(G_ede_fuctional.csr)
```

::: callout-important
**Conclusion**: The observed G(r) is far above the G(theo) as well as the envelope - indicating that Functional Water Point in the Ede area are clustered. Hence, we reject the null hypothesis that Functional Water Point in the Ede area are randomly distributed at 99% confident interval**.**
:::

#### Computing G_Function Estimate for Non Functional Water Point

```{r}
G_ede_non = Gest(wp_nonfunctional_ede_ppp.km, correction = "border")
plot(G_ede_non)
```

#### Testing the Hypothesis of Non Functional Water Point

**Our Hypothesis:**

-   H0: The distribution of the Non Functional Water Points in Ede are randomly distributed

-   H1: The distribution of the Non Functional Water Points in Ede are not randomly distributed

-   Confidence level : 99%

-   Significance level : 0.01

-   The null hypothesis will be rejected if p-value is smaller than alpha value of 0.01.

```{r}
G_ede_nonfuctional.csr <- envelope(wp_nonfunctional_ede_ppp.km, Gest, nsim=100)
```

```{r}
plot(G_ede_nonfuctional.csr)
```

::: callout-important
**Conclusion**: The observed G(r) is far above the G(theo) as well as the envelope - indicating that Non Functional Water Point in the Ede area are clustered. Hence, we reject the null hypothesis that Non Functional Water Point in the Ede area are randomly distributed at 99% confident interval**.**
:::

### Osun

#### Computing G_Function Estimate for Functional Water Point

```{r}
G_osun = Gest(wp_functional_osun_ppp.km, correction = "border") 
plot(G_osun)
```

#### Testing the Hypothesis for Functional Water Point

**Our Hypothesis:**

-   H0: The distribution of the Functional Water Points in Osun are randomly distributed

-   H1: The distribution of the Functional Water Points in Osun are not randomly distributed

-   Confidence level : 99%

-   Significance level : 0.01

-   The null hypothesis will be rejected if p-value is smaller than alpha value of 0.01.

```{r}
G_osun_fuctional.csr <- envelope(wp_functional_osun_ppp.km, Gest, nsim=100)
```

```{r}
plot(G_osun_fuctional.csr)
```

::: callout-important
Conclusion: The observed G(r) is far above the G(theo) as well as the envelope - indicating that Functional Water Point in the Osun area are clustered. Hence, we reject the null hypothesis that Functional Water Point in the Osun area are randomly distributed at 99% confident interval**.**
:::

#### Computing G_Function Estimate for Non Functional Water Point

```{r}
G_osun_non = Gest(wp_nonfunctional_osun_ppp.km, correction = "border") 
plot(G_osun_non)
```

#### Hypothesis Testing For Non Functional Water Point

**Our Hypothesis:**

-   H0: The distribution of the Non Functional Water Points in Osun are randomly distributed

-   H1: The distribution of the Non Functional Water Points in Osun are not randomly distributed

-   Confidence level : 99%

-   Significance level : 0.01

-   The null hypothesis will be rejected if p-value is smaller than alpha value of 0.01.

```{r}
G_osun_nonfuctional.csr <- envelope(wp_nonfunctional_osun_ppp.km, Gest, nsim=100)
```

```{r}
plot(G_osun_nonfuctional.csr)
```

::: callout-important
**Conclusion**: The observed G(r) is far above the G(theo) as well as the envelope - indicating that Non Functional Water Point in the Osun area are clustered. Hence, we reject the null hypothesis that Functional Water Point in the Osun area are randomly distributed at 99% confident interval**.**
:::

## Conclusion for 2nd Order Spatial Point Analysis

### Areas with High Functional Water Point and Non Functional Water Point are clustered together in the cities in Osun

Based on our G Function Analysis, since we have determined that both the Functional Water Point and the Non Functional Point are not randomly distributed at 99% Confidence interval in Osun. Hence, we can determine that they are clusted together

### Functional and Non Functional Water Point are clustered together in cities of Osun

Based on our G Function Analysis, since we have determined that both the Functional Water Point and the Non Functional Point are not randomly distributed at 99% Confidence interval in 3 main cities Iwo, Osogbo and Ede. Hence, we can determine that they are clusted together

# Spatial Correlation Analysis

Know that we have determined that both the Functional Water Point and Non Functional Water Points are not randomly distributed but clustered, we are given a rather interesting question, are they independent of each other. In other words, does the presence of a functional water point affect the presence of another water point.

Therefore we have come up with 2 new Hypothesis for Functional and Non Functional:

**Our Hypothesis:**

-   H0: The distribution of the Water Points are independent of each other

-   H1: The distribution of the Non Functional Water Points are not independent of each other.

-   Confidence level : 95%

We will be testing this Hypothesis on the Functional and Non Functional Water Points only in the State of Osun.

## Computing L Function

In order to test for Correlation we would need to perform a K Function. [K function is a popular technique for analyzing spatial correlation in point patterns.](https://book.spatstat.org/sample-chapters/chapter07.pdf) It measures the number of events found up to a given distance of any particular event, [according to Prof.](https://r4gdsa.netlify.app/chap05.html#analysing-spatial-point-process-using-k-function) This makes it perfect for testing for Spatial Correlation Analysis.

However,[K Function makes it difficult for us to discern difference between the Theortical K and Predicted K at lower values](http://personal.colby.edu/personal/m/mgimond/Spatial/K%20and%20L%20functions.html), as such we will be making use of the L Function instead. L Function is a transformation of K Function before applying a square root transformation, which theoretical stabilised the variance of the estimator.

For us to perform L Function Analysis we will be making use of Lest() Function from spatstat. [Find out more about Lest() Function from spatstat here](https://www.rdocumentation.org/packages/spatstat/versions/1.64-1/topics/Lest). To further confirm our Hypothesis we would need to perform a Monte Carlo Simulation Test with G Function to test our Hypothesis.

### Functional Water Point

#### Computing L Function Estimate

```{r}
#| eval: false
L_fun_osun = Lest(wp_functional_osun_ppp.km, correction = "Ripley")
plot(L_fun_osun, . -r ~ r, 
     ylab= "L(d)-r", xlab = "d")
```

![](images/L_Functional_Curve-01.png)

#### Testing the Hypothesis on Functional Water Point

**Our Hypothesis:**

-   H0: The distribution of the Functional Water Points in Osun are independent of each other

-   H1: The distribution of the Functional Water Points in Osun are not independent of each other

-   Confidence level : 95%

-   Significance level : 0.05

-   The null hypothesis will be rejected if p-value is smaller than alpha value of 0.05.

```{r}
#| eval: false

L_fun_osun.csr <- envelope(wp_functional_osun_ppp.km, Lest, nsim = 39, rank = 1, glocal=TRUE)
```

```{r}
#| eval: false
plot(L_fun_osun.csr, . - r ~ r, xlab="d", ylab="L(d)-r")
```

![](images/L_Func_MonteCarlo.png)

::: callout-important
**Conclusion**: The observed L(r)-r(obs) is far above the L(r)-r(theo) as well as the envelope for almost all distance of d- indicating that Functional Water Point in the Osun are not independent of each other. Hence, we reject the null hypothesis that Functional Water Point in the Osun are independent of each other at all distance of d at 95% confidence interval.
:::

### Non Functional Water Point

#### Computing L Function Estimate

```{r}
#| eval: false
L_non_fun_osun = Lest(wp_nonfunctional_osun_ppp.km, correction = "Ripley")
plot(L_non_fun_osun, . -r ~ r, 
     ylab= "L(d)-r", xlab = "d")
```

![](images/L_NonFunctional_Curve.png)

#### Testing the Hypothesis of Non Functional Water Point

**Our Hypothesis:**

-   H0: The distribution of the Non Functional Water Points in Osun are independent of each other

-   H1: The distribution of the Non Functional Water Points in Osun are not independent of each other

-   Confidence level : 95%

-   Significance level : 0.05

-   The null hypothesis will be rejected if p-value is smaller than alpha value of 0.05.

```{r}
#| eval: false
L_non_fun_osun.csr <- envelope(wp_nonfunctional_osun_ppp.km, Lest, nsim = 39, rank = 1, glocal=TRUE)
```

```{r}
#| eval: false
plot(L_non_fun_osun.csr, . - r ~ r, xlab="d", ylab="L(d)-r")
```

![](images/L_NonFunctional_MonteCarlo.png)

::: callout-important
**Conclusion**: The observed L(r)-r(obs) is far above the L(r)-r(theo) as well as the envelope for almost all distance of d- indicating that Non Functional Water Point in the Osun are not independent of each other. Hence, we reject the null hypothesis that Non Functional Water Point in the Osun are independent of each other at all distance of d at 95% confidence interval.
:::

## Conclusion

### Functional Water Point are not independent of each other in the State of Osun

Based on the Conclusion of L Function Test, we need to reject the null hypothesis that Functional Water Point in the Osun are independent of each other at all distance of d at 95% confidence interval, therefore we can conclude that Functional Water Point in the Osun area are not independent of each other.

### Non Functional Water Point are not independent of each other in the State of Osun

Based on the Conclusion of L Function Test, we need to reject the null hypothesis that Non Functional Water Point in the Osun are independent of each other at all distance of d at 95% confidence interval, therefore we can conclude that Functional Water Point in the Osun area are not independent of each other.

# Special Thanks

Special Thanks to Dr Kam Tin Seong for his guidance and help.
